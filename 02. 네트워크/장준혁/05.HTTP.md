## 5. HTTP

### HTTP/1.0

한 연결당 하나의 요청을 처리하도록 설계되었으며 이는 RTT 증가를 불러오게 되었다. 서버로부터 파일을 가져올 때마다 TCP의 3웨이 핸드셰이크를 계속해서 열어야 하기 떄문이다. 이를 해결하기 위해 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩을 사용했다.

### HTTP/1.1

매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 이후 keep-alive 옵션으로 여러 개의 파일을 송수신할 수 있게 바뀌었다. 한 번 3웨이 핸드셰이크가 발생하면 그다음부터 발생하지 않는다. 하지만 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 성능 저하 현상인 HOL Blocking이나 헤더에 쿠키 등 많은 메타데이터가 들어있고 압축이 되지 않아 헤더가 무거웠다.

### HTTP/2

HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있어 멀티플렉싱, 헤더 압축, 서버 푸시, 요청 우선순위 처리를 지원한다.

- 멀티플렉싱 : 여러 개의 스트림을 사용하여 송수신하는 것. 애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 이후 다시 조립하며 데이터를 주고받는다. 이를 통해 여러 요청을 받을 수 있고 HOL Blocking을 해결할 수 있다.
- 헤더 압축 : 허프만 코딩 압축 알고리즘을 사용한 HPACK 압축으로 헤더를 압축하여 전송한다.
- 서버 푸시 : 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있다. html에 css나 js파일이 포함되어 있다면 html을 읽으면서 그 안에 들어 있던 css 파일을 서버에 푸시하여 클라이언트에 먼저 줄 수 있다.

### HTTPS

HTTP/2는 HTTPS 위에서 동작하며 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 HTTP 요청이다.

- SSL/TLS : SSL은 버전이 올라가 마지막으로 TLS로 명칭이 변경되었으나 보통 SSL/TLS로 많이 부르며 최신 TLS버전은 TLS 1.3이다. 보안을 제공하는 프로토콜이며 클라이언트와 서버가 통신할 때 제3자가 메시지를 도청하거나 변조하지 못하도록 한다. 보안 세션을 기반으로 데이터를 암호화하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 알고리즘, 해싱 알고리즘이 사용된다. TLS1.3은 사용자가 이전에 방문한 사이트로 다시 방문하면 보안 세션을 만들 때 걸리는 통신을 하지 않아도 된다. 이를 0-RTT라고 한다. 구글은 HTTPS를 서비스하는 사이트가 SEO 순위가 높을 것이라고 밝혔다.

### HTTP/3

TCP 위에서 돌아가는 HTTP/2와는 달리 HTTP/3은 QUIC 계층 위에서 돌아가며 UDP 기반으로 돌아간다. 3웨이 핸드셰이크 과정을 거치지 않아도 되며 QUIC는 첫 연결 설정에 1-RTT만 소요된다. 순방향 오류 수정 메커니즘(FEC)이 적용되어 전송한 패킷이 손실되었다면 에러를 검출하고 수정한 방식이며 열악한 네트워크 환경에서도 낮은 패킷 손실률을 자랑한다.
